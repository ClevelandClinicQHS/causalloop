#' @param label Label to assign to a feedback loop in \code{setLoopLabel()}.
#'
#' @return a list of 2-element lists, each with element \code{[[1]]} containing
#'   a feedback loop and element \code{[[2]]} containing the loop's type (i.e.,
#'   either "balancing" or "reinforcing"). Balancing loops have an odd number
#'   of links with negative polarity, and reinforcing loops have an even
#'   number of links with negative polarity.
#' @export
#'
#' @details This function applies Johnson's algorithm for finding cycles
#'   in a directed graph. In particular, we adapt for the \code{causalloop}
#'   package Jacobien Carstens' implementation of Johnson's algorithm,
#'   which can be found on GitHub at the link below (see References)
#'
#' @references
#'   Johnson, D. B. (1975). Finding all the elementary circuits of a
#'   directed graph. SIAM Journal on Computing, 4(1), 77-84.
#'
#'   Carstens, J. R implementation of Johnson's algorithm.
#'   \url{https://github.com/queenBNE/DirectedGraphsCycles}
#
#'
#' @examples
#' edges <- tibble::tribble(
#' ~from, ~to, ~polarity,
#' 1,2,1,
#' 1,5,1,
#' 1,8,1,
#' 2,3,-1,
#' 2,7,1,
#' 2,9,1,
#' 3,1,1,
#' 3,2,1,
#' 3,4,1,
#' 3,6,-1,
#' 4,5,1,
#' 5,2,1,
#' 6,4,1,
#' 8,9,-1,
#' 9,8,1
#' )
#' txtedges <- edges %>% dplyr::mutate(from = letters[from], to = letters[to])
#' z <- CLD(txtedges$from, txtedges$to, polarity = txtedges$polarity)
#' getLoops(z)
#'
getLoops <- function(x){
# make:
#  1) a lookup table from node labels in x$edges to integer nodeIDs; and
#  2) an igraph object with the graph structure (index by the integer nodeIDs)
# if(!causalloop:::allEdfNodesListedInNdf(x)) {
#   stop("The 'edges' table in the CLD object contains nodes not in the 'nodes' table.")
# }
nodeIxTable <- dplyr::select(x$nodes, node) %>%
dplyr::group_by(node) %>%
dplyr::filter(dplyr::row_number() == 1) %>%
dplyr::ungroup() %>%
dplyr::rename(from = node) %>%
dplyr::mutate(to = from,
nodeID = 1:n())
edf <- dplyr::select(x$edges, from, to, polarity) %>%
dplyr::left_join(nodeIxTable[,c("from","nodeID")], by = "from") %>%
dplyr::rename(fromID = nodeID) %>%
dplyr::left_join(nodeIxTable[,c("to","nodeID")], by = "to") %>%
dplyr::rename(toID = nodeID)
nodeID_graph <- igraph::graph_from_data_frame(edf[,c("fromID","toID")])
# This function, adapted from Carstens' R implementation of Johnson's algorithm,
# computes the "elementary" cycles of a directed graph g.
get_elementary_cycles <- function(g){
#Subroutine to obtain the strong component of a graph g with the lowest-numbered
#vertex in the subgraph of g induced by vertices {s, s+1, ... n}. The algorithm
#is given in Johnson (1975) (see references).
get.induced.strong <- function(g, s){
# Create the induced subgraph on {s, s+1, ..., n} and compute the strong components
sg <- igraph::induced.subgraph(g, vids=s:igraph::vcount(g))
sc <- igraph::clusters(sg, mode="strong")
# Obtain the names for the remaining nodes - this has to be done to make sure that we use
# the right order of nodes, we want to find the strong component with the least vertex.
# Igraph always uses ids 1:n' for a graph, so we need to use the names.
ids <- as.numeric(igraph::get.vertex.attribute(sg, "name", 1:igraph::vcount(sg)))
order <- sort(ids, index.return=TRUE)$ix
# Obtain the vertices of the strong component with the least vertex
others <- c()
for(v in order)
if(length(others) <= 1)
others <- which(sc$membership == sc$membership[v])
# If there is a strong component with more than 1 vertex, return this component
if(length(others) > 1)
return(igraph::induced.subgraph(sg, others))
# Else return NULL
else
return(NULL)
}
# Subroutine returning a list where u is unblocked and all vertices in B(u)
# are unblocked (recursively)
unblock <- function(u, b, B){
b[u] <- FALSE
for(w in B[[u]]){
B[[u]] <- B[[u]][-which(B[[u]]==w)]
if(b[w]){
bB <- unblock(w,b,B)
b <- bB$b
B <- bB$B
}
}
return(list(b=b, B=B))
}
# Subroutine to produce the circuits (cycles) starting at vertex s
circuit <- function(s, v, Ak, B, b, f, stack, ids){
stack <- c(stack, v)
b[v] <- TRUE
for(w in igraph::neighbors(Ak, v, mode="out")){
if(w==s){
cat(sapply(c(stack,s), FUN=function(i){return(ids[i])}), sep=" ")
cat("~")
f = TRUE
}else if (!b[w]){
updated <- circuit(s,w,Ak,B,b,f,stack,ids)
B <- updated$B
b <- updated$b
stack <- updated$stack
if(updated$f)
f = TRUE
}
}
if(f){
updated <- unblock(v, b, B)
b <- updated$b
B <- updated$B
}else{for(w in igraph::neighbors(Ak, v, mode="out"))
if (! v %in% B[[w]])
B[[w]] <- c(B[[w]], v)
}
stack <- stack[-length(stack)]
return(list(B=B, b=b, f=f, stack=stack))
}
b <- rep(FALSE, igraph::vcount(g))
B <- vector("list", igraph::vcount(g))
s = 1
while(s < igraph::vcount(g)){
Ak <- get.induced.strong(g,s)
if(!is.null(Ak)){
ids <- as.numeric(igraph::get.vertex.attribute(Ak, "name", 1:igraph::vcount(Ak)))
s <- min(ids)
for(i in ids){
b[i] <- FALSE
B[[i]] <- numeric(0)
}
s_indx <- which(ids == s)
circuit(s_indx, s_indx, Ak, B, b, FALSE, numeric(0), ids)
s <- s + 1
}else
s <- igraph::vcount(g)
}
}
nodeID_graph_cycles <- capture.output(get_elementary_cycles(nodeID_graph))
nodeID_graph_cycles <- as.list(strsplit(nodeID_graph_cycles, "~")[[1]])
txt2vec <- function(l) strsplit(l, split = " ") %>% unlist() %>% as.numeric()
nodeID_graph_cycles <- purrr::map(nodeID_graph_cycles, txt2vec)
nodeIxTable <- dplyr::select(nodeIxTable, nodeID, from) %>%
dplyr::rename(node = from)
makeCycleListOutput <- function(l){
cycle <- tibble::tibble(fromID = l[1:(length(l)-1)],
toID   = l[2:length(l)]) %>%
dplyr::left_join(edf, by=c("fromID","toID")) %>%
dplyr::select(from, to, polarity)
type = dplyr::case_when(prod(cycle$polarity) == -1 ~ "Balancing",
prod(cycle$polarity) == +1 ~ "Reinforcing")
return(list(cycle = cycle,
type = type))
}
Result <- purrr::map(nodeID_graph_cycles, makeCycleListOutput)
tmp <- purrr::map2(as.list(1:length(Result)), as.list(rep("",length(Result))),
function(.x, .y) list(loopIx = .x, label = .y))
Result <- purrr::map2(tmp, Result,
function(.x, .y) list(loopIx = .x$loopIx,
label  = .x$label,
type   = .y$type,
cycle  = .y$cycle))
class(Result) <- "feedbackLoops"
Result
}
#' @rdname getLoops
#' @export setLoopLabel
setLoopLabel <- function(FBL, loopIx, label){
stopifnot(class(FBL) == "feedbackLoops")
purrr::map_if(FBL,
.p = function(.x) .x$loopIx == loopIx,
.f = function(.x) {
.x$label <- label
.x
}
)
}
loops <- setLoopLabel(loops, 5, "BCFdE!)
"")
loops <- getLoops(z)
loops <- setLoopLabel(loops, 5, "BCFdE!")
loops
loops <- setLoopLabel(loops, loopIx = 5, label = "BCFdE!")
roxygen2::roxygenise()
devtools::install_github("jarrod-dalton/causalloop")
devtools::load_all()
edges <- tibble::tribble(
~from, ~to, ~polarity,
1,2,1,
1,5,1,
1,8,1,
2,3,-1,
2,7,1,
2,9,1,
3,1,1,
3,2,1,
3,4,1,
3,6,-1,
4,5,1,
5,2,1,
6,4,1,
8,9,-1,
9,8,1
)
txtedges <- edges %>% dplyr::mutate(from = letters[from], to = letters[to])
z <- CLD(txtedges$from, txtedges$to, polarity = txtedges$polarity)
loops <- getLoops(z)
loops <- setLoopLabel(loops, loopIx = 5, label = "BCFdE!")
loops
library(causalloop)
edges <- tibble::tribble(
~from, ~to, ~polarity,
1,2,1,
1,5,1,
1,8,1,
2,3,-1,
2,7,1,
2,9,1,
3,1,1,
3,2,1,
3,4,1,
3,6,-1,
4,5,1,
5,2,1,
6,4,1,
8,9,-1,
9,8,1
)
txtedges <- edges %>% dplyr::mutate(from = letters[from], to = letters[to])
z <- CLD(txtedges$from, txtedges$to, polarity = txtedges$polarity)
loops <- getLoops(z)
loops <- setLoopLabel(loops, loopIx = 5, label = "BCFdE!")
loops
loopToTibble <- function(l){
l$cycle %>%
dplyr::mutate(loopIx = l$loopIx,
label  = l$label) %>%
return
}
FBL
q
loops
FBL <- loops
purrr::map(FBL, loopToTibble)
plotData <- l$cycle %>%
dplyr::mutate(loopIx = l$loopIx,
label  = l$label) %>%
dplyr::bind_rows
loopToTibble <- function(l){
l$cycle %>%
dplyr::mutate(loopIx = l$loopIx,
label  = l$label) %>%
return
}
purrr::map(FBL, loopToTibble)
purrr::map(FBL, loopToTibble) %>% dplyr::bind_rows
purrr::map(FBL, loopToTibble) %>% dplyr::bind_rows()
loopToTibble <- function(l){
l$cycle %>%
dplyr::mutate(loopIx = l$loopIx,
label  = paste0(l$loopIx, ": ", l$label) %>%
return
}
plotData <- purrr::map(FBL, loopToTibble) %>%
dplyr::bind_rows()
loopToTibble <- function(l){
l$cycle %>%
dplyr::mutate(loopIx = l$loopIx,
label  = paste0(l$loopIx, ": ", l$label)) %>%
return
}
pd <- purrr::map(FBL, loopToTibble) %>% dplyr::bind_rows()
pd
loopToTibble <- function(l){
l$cycle %>%
dplyr::mutate(loopIx = l$loopIx,
type   = l$type,
label  = paste0(l$loopIx, ": ", l$label)) %>%
return
}
pd <- purrr::map(FBL, loopToTibble) %>% dplyr::bind_rows()
pd
FBL
FBL
purrr::map(FBL, function(l){
tibble::tibble(loopIx = l$loopIx, nodes = c(l$cycle$from, l$cycle$to))
)
purrr::map(FBL, function(l){
tibble::tibble(loopIx = l$loopIx, nodes = c(l$cycle$from, l$cycle$to))
}
}
purrr::map(FBL, function(l){
tibble::tibble(loopIx = l$loopIx, nodes = c(l$cycle$from, l$cycle$to))
})
FBL.nodes <- purrr::map(FBL, function(l){
tibble::tibble(loopIx = l$loopIx, nodes = c(l$cycle$from, l$cycle$to))
}) %>% dplyr::bind_rows()
FBL.nodes
FBL.nodes %>% print(n=1000)
FBL.nodes <- purrr::map(FBL, function(l){
tibble::tibble(loopIx = l$loopIx, nodes = c(l$cycle$from, l$cycle$to))
})
FBL.nodes <- FBL.nodes %>%
dplyr::bind_rows() %>%
dplyr::group_by(loopIx, nodes) %>%
dplyr::filter(dplyr::row_number() == 1) %>%
dplyr::ungroup()
FBL.nodes
#make tibble containing the selected feedback loops
loopToTibble <- function(l){
l$cycle %>%
dplyr::mutate(loopIx = l$loopIx,
type   = l$type,
label  = paste0(l$loopIx, ": ", l$label)) %>%
return
}
pd <- purrr::map(FBL, loopToTibble) %>% dplyr::bind_rows()
pd
nodes <- c("a","h")
right_join(tibble::tibble(nodes = nodes), FBL.nodes)
dplyr::right_join(tibble::tibble(nodes = nodes), FBL.nodes)
FBL
tibble::tibble(nodes = nodes)
dplyr::left_join(tibble::tibble(nodes = nodes), FBL.nodes)
selectedLoops <- dplyr::left_join(tibble::tibble(nodes = nodes), FBL.nodes) %>%
dplyr::select(loopIx)
selectedLoops
selectedLoops <- dplyr::left_join(tibble::tibble(nodes = nodes), FBL.nodes) %>%
dplyr::select(loopIx) %>%
as.numeric()
all(c("a","c") %in% letters[1:5])
FBL
purrr::map_if(FBL, function(.x) .x$loopIx %in% loopIx, function(.x) .x)
loopIx <- c(3,5)
purrr::map_if(FBL, function(.x) .x$loopIx %in% loopIx, function(.x) .x)
map(FBL, function(.x) .x$loopIx)
purrr::map(FBL, function(.x) .x$loopIx)
purrr::map(FBL, function(.x) .x$loopIx %in% loopIx)
purrr::map(FBL, function(.x) which(.x$loopIx %in% loopIx))
purrr::map(FBL, function(.x) .x$loopIx %in% loopIx)
FBL[unlist(purrr::map(FBL, function(.x) .x$loopIx %in% loopIx))]
length(FBL)
FBL <- FBL[unlist(purrr::map(FBL, function(.x) .x$loopIx %in% loopIx))]
FBL
length(FBL)
nodes
loops
FBL <- loops
stopifnot(is.character(nodes) | is.numeric(nodes))
#get table of nodes involved with each loop
FBL.nodes <- purrr::map(FBL, function(l){
tibble::tibble(loopIx = l$loopIx, nodes = c(l$cycle$from, l$cycle$to))
})
FBL.nodes <- FBL.nodes %>%
dplyr::bind_rows() %>%
dplyr::group_by(loopIx, nodes) %>%
dplyr::filter(dplyr::row_number() == 1) %>%
dplyr::ungroup()
selectedLoops <- dplyr::left_join(tibble::tibble(nodes = nodes), FBL.nodes) %>%
dplyr::select(loopIx)
if(nrow(loopIx) == 0) {
stop("No loops found involving the variables given in 'nodes'!")
}
selectedLoops <- dplyr::left_join(tibble::tibble(nodes = nodes),
FBL.nodes, by = "nodes") %>%
dplyr::select(loopIx)
selectedLoops
if(nrow(selectedLoops) == 0) {
stop("No loops found involving the variables given in 'nodes'!")
}
library(causalloop)
FBL
length(FBL)
nodes
plot(FBL, nodes = nodes)
FBL
nodes
stopifnot(class(FBL) == "feedbackLoops")
.dots <- list(...)
library(causalloop)
plot(FBL, nodes = nodes)
.dots = list(nodes=nodes)
if(all(c("nodes","loopIx") %in% names(.dots))){
stop("Either 'nodes' or 'loopIx' can be specified, but not both.")
}
"nodes" %in% names(.dots)
stopifnot(is.character(nodes) | is.numeric(nodes))
#get table of nodes involved with each loop
FBL.nodes <- purrr::map(FBL, function(l){
tibble::tibble(loopIx = l$loopIx, nodes = c(l$cycle$from, l$cycle$to))
})
FBL.nodes <- FBL.nodes %>%
dplyr::bind_rows() %>%
dplyr::group_by(loopIx, nodes) %>%
dplyr::filter(dplyr::row_number() == 1) %>%
dplyr::ungroup()
selectedLoops <- dplyr::left_join(tibble::tibble(nodes = nodes),
FBL.nodes, by = "nodes") %>%
dplyr::select(loopIx)
FBL <- FBL[unlist(purrr::map(FBL, function(.x) .x$loopIx %in% selectedLoops$loopIx))]
FBL
"loopIx" %in% names(.dots)
if(length(FBL) == 0){
stop("No loops found involving the loop indices given in 'loopIx'!")
}
#make tibble containing the selected feedback loops
loopToTibble <- function(l){
l$cycle %>%
dplyr::mutate(loopIx = l$loopIx,
type   = l$type,
label  = paste0(l$loopIx, ": ", l$label)) %>%
return
}
pd <- purrr::map(FBL, loopToTibble) %>% dplyr::bind_rows()
pd
plot.feedbackLoops <- function(FBL, ...){
stopifnot(class(FBL) == "feedbackLoops")
.dots <- list(...)
if(all(c("nodes","loopIx") %in% names(.dots))){
stop("Either 'nodes' or 'loopIx' can be specified, but not both.")
}
if("nodes" %in% names(.dots)){
stopifnot(is.character(nodes) | is.numeric(nodes))
#get table of nodes involved with each loop
FBL.nodes <- purrr::map(FBL, function(l){
tibble::tibble(loopIx = l$loopIx, nodes = c(l$cycle$from, l$cycle$to))
})
FBL.nodes <- FBL.nodes %>%
dplyr::bind_rows() %>%
dplyr::group_by(loopIx, nodes) %>%
dplyr::filter(dplyr::row_number() == 1) %>%
dplyr::ungroup()
selectedLoops <- dplyr::left_join(tibble::tibble(nodes = nodes),
FBL.nodes, by = "nodes") %>%
dplyr::select(loopIx)
FBL <- FBL[unlist(purrr::map(FBL, function(.x) .x$loopIx %in% selectedLoops$loopIx))]
}
if("loopIx" %in% names(.dots)){
stopifnot(is.numeric(loopIx))
FBL <- FBL[unlist(purrr::map(FBL, function(.x) .x$loopIx %in% loopIx))]
}
if(length(FBL) == 0){
stop("No loops found involving the loop indices given in 'loopIx'!")
}
#make tibble containing the selected feedback loops
loopToTibble <- function(l){
l$cycle %>%
dplyr::mutate(loopIx = l$loopIx,
type   = l$type,
label  = paste0(l$loopIx, ": ", l$label)) %>%
return
}
pd <- purrr::map(FBL, loopToTibble) %>% dplyr::bind_rows()
pd
}
plot.feedbackLoops(FBL, nodes = nodes)
FBL <- loops
plot.feedbackLoops(FBL, nodes = nodes)
plot(FBL)
plot(FBL, nodes = nodes)
library(causalloop)
plot(FBL, nodes = nodes)
# Just put your dishIDs here and run the program
dishIDs <- c(62,3,63,38,65)
excludedDishIDs <- c(57)
excludedIngredients <- c();# c(30,33,130,41,10,11,6,134,93,98,131,49)
#--------------------------------------------------------------------
require(XLConnect);  require(reshape2);
setwd("~/Google Drive/personal/meals")
#setwd("C:/Users/daltonj/Google Drive/personal/meals")
source("r/makeMenu.R")
source("r/makeGroceryList.R")
source("r/load_data.R")
FN <- paste("Grocery List ",Sys.Date(),".txt",sep="")
fileConn<-file(FN);
writeLines(makeGroceryList(dishIDs,excludedDishIDs,excludedIngredients,Sys.Date()), fileConn);
close(fileConn)
install.packages("XLConnect")
# Just put your dishIDs here and run the program
dishIDs <- c(62,3,63,38,65)
excludedDishIDs <- c(57)
excludedIngredients <- c();# c(30,33,130,41,10,11,6,134,93,98,131,49)
#--------------------------------------------------------------------
require(XLConnect);  require(reshape2);
setwd("~/Google Drive/personal/meals")
#setwd("C:/Users/daltonj/Google Drive/personal/meals")
source("r/makeMenu.R")
source("r/makeGroceryList.R")
source("r/load_data.R")
FN <- paste("Grocery List ",Sys.Date(),".txt",sep="")
fileConn<-file(FN);
writeLines(makeGroceryList(dishIDs,excludedDishIDs,excludedIngredients,Sys.Date()), fileConn);
close(fileConn)
''
rm(list=ls())
q("no")
