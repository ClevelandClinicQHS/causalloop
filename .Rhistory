dplyr::group_by(node) %>%
dplyr::filter(row_number() == 1) %>%
dplyr::ungroup() %>%
dplyr::rename(from = node) %>%
dplyr::mutate(to = from,
nodeID = 1:n())
nodeIxTable
library(causalloop)
L <- CLD(from=c("a","a","c","c","d"), to=c("b","c","a","d","a"))
L$edges
plot(L)
str(L)
CLD <- L
stopifnot(class(CLD) == "CLD")
#first, make sure all nodes in the edges table are in the nodes table
if(!causalloop:::allEdfNodesListedInNdf(CLD)){
stop("CLD$edges contains nodes that are absent in CLD$nodes.")
}
if(!all(CLD$nodes$group %in% CLD$formats$node$group)){
zz <- setdiff(CLD$nodes$group, CLD$formats$node$group)
stop(paste0("Node group(s) '", paste(zz, collapse="', '"),
"' do not exist. Use addNodeGroup()."))
}
#map node data to what DiagrammeR wants (integer node IDs)
ndf <- DiagrammeR::create_node_df(n     = nrow(CLD$nodes),
type  = CLD$nodes$group,
label = CLD$nodes$node)
nodeFmtData <- CLD$formats$node %>% dplyr::rename(type=group)
ndf  <- dplyr::left_join(ndf, nodeFmtData, by="type")
nodeIDs <- ndf %>% select(id,label)
nodeIDs <- ndf %>% dplyr::select(id,label)
edf <- CLD$edges %>%
dplyr::left_join(CLD$formats$edge, by="polarity") %>%
dplyr::rename(label=from) %>%
dplyr::left_join(nodeIDs, by="label") %>%
dplyr::select(-label) %>%
dplyr::rename(from=id, label=to) %>%
dplyr::left_join(nodeIDs, by="label") %>%
dplyr::select(-label) %>%
dplyr::rename(to=id)
edf <- DiagrammeR::create_edge_df(from      = edf$from,
to        = edf$to,
polarity  = edf$polarity,
style     = edf$style,
color     = edf$color,
arrowhead = edf$arrowhead,
penwidth  = edf$penwidthAdj*edf$weight)
if(!is.null(nodes)){
if(any(!(nodes %in% CLD$nodes$node))){
warning(paste0("The following nodes were not in the CLD ",
"and will be ignored:\n     '",
paste0(setdiff(nodes, CLD$nodes$node),
collapse="'\n     '")), "'")
nodes <- nodes[nodes %in% CLD$nodes$node]
}
if(length(nodes)==0) stop("No nodes present in the CLD!")
nodes <- ndf$id[ndf$label %in% nodes]  #map nodes to node indices
stopifnot(is.numeric(steps) & length(steps)==1)
steps <- floor(steps)
inNodes <- outNodes <- origNodes <- nodes
if(steps>0)  for(i in 1:steps) {
inNodes  <- unique(c(inNodes, edf$from[which(edf$to %in% inNodes)]))
outNodes <- unique(c(outNodes, edf$to[which(edf$from %in% outNodes)]))
}
nodes <- unique(c(inNodes,outNodes))
ndf <- ndf %>% dplyr::filter(id %in% nodes)
edf <- edf %>% dplyr::filter(from %in% nodes & to %in% nodes)
ix <- which(!(edf$from %in% origNodes) & !(edf$to %in% origNodes))
if(recolor & length(ix)>0) edf$color[ix] <- "gray70"
}
ndf$label <- stringr::str_wrap(ndf$label, width = textWidth)
textWidth = 10
recolor=TRUE
ndf$label <- stringr::str_wrap(ndf$label, width = textWidth)
g <- DiagrammeR::create_graph(nodes_df=ndf, edges_df=edf) %>%
DiagrammeR::add_global_graph_attrs(attr      = "overlap",
value     = "false",
attr_type = "graph")
DiagrammeR::render_graph(g)
L <- CLD(from     = c("a","a","b","c","d","d","e"),
to       = c("b","c","a","d","b","a","d"),
polarity = c(1,1,-1,-1,1,-1,1)) %>%
addNodeData(tibble(node="c", group="core")) %>%
addNodeGroup("core", fontcolor="red", color="yellow")
L <- CLD(from     = c("a","a","b","c","d","d","e"),
to       = c("b","c","a","d","b","a","d"),
polarity = c(1,1,-1,-1,1,-1,1)) %>%
addNodeData(tibble::tibble(node="c", group="core")) %>%
addNodeGroup("core", fontcolor="red", color="yellow")
plot(L)
L <- CLD(from     = c("a","a","b","c","d","d","e"),
to       = c("b","c","a","d","b","a","d"),
polarity = c(1,1,-1,-1,1,-1,1))
L
L <- CLD(from     = c("a","a","b","c","d","d","e"),
to       = c("b","c","a","d","b","a","d"),
polarity = c(1,1,-1,-1,1,-1,1)) %>%
addNodeData(tibble::tibble(node="c", group="core"))
L$nodes
#' Load node data into a CLD object
#'
#' @description This function takes a \emph{node data frame}, consisting of character
#'   variables \code{node} and (optionally) \code{group}, and populates the \code{nodes}
#'   list element in the supplied \code{CLD} object.
#'
#' @param CLD A causal loop diagram (CLD) object.
#'
#' @param ndf A node data frame containing at least a character column \code{node}.
#'   When \code{ndf} is specified, \code{edf2CLD()} loads the node information into the
#'   CLD object and checks the names of the variables contained in \code{edf$from} and
#'   \code{edf$to} for membership in \code{ndf$node}. This data frame may optionally contain
#'   a column named \code{group} to designate individual variables into groups. All other
#'   variables are ignored.
#'
#' @param replace If \code{TRUE}, \code{addNodeData()} will replace the existing
#'   \code{nodes} list element within the supplied \code{CLD} object. If \code{FALSE},
#'   the existing \code{nodes} data will be updated to include any new information
#'   embedded within \code{ndf}. Importantly, when \code{replace == TRUE}, the function
#'   verifies that all nodes represented in the \code{edges} table within the \code{CLD}
#'   object are listed in the supplied \code{ndf} (i.e., in \code{ndf$node}).
#'
#' @param sorted If \code{TRUE}, the \code{nodes} list element in the returned \code{CLD}
#'   object is sorted in order of the node name (column \code{node}).
#'
#' @return An updated CLD object.
#' @export
#'
#' @examples
#' \dontrun{
#' L <- CLD(from=c("a","a","c","c","d"), to=c("b","c","a","d","a"))
#' L$nodes
#' ndat <- tibble(node=c("c","d","e","f"), group=c("I"," ","II","I"))
#' L <- addNodeData(L, ndat)
#' L$nodes #note updating behavior - also that the missing value gets mapped to "<default>"
#' M <- addNodeData(L, ndat, replace=TRUE) #produces error
#' }
addNodeData <- function(CLD, ndf, replace=FALSE, sorted=TRUE){
stopifnot(class(CLD) == "CLD")
stopifnot(is.data.frame(ndf))
stopifnot("node" %in% names(ndf))
stopifnot(is.character(ndf$node))
nodes <- ndf$node
if(any(duplicated(nodes))){
stop("Duplicate node(s) specified in the 'ndf' table.")
}
if("group" %in% names(ndf)){
stopifnot(is.character(ndf$group))
gps <- ndf$group
} else {
warning("No 'group' variable specified in parameter 'ndf'. Setting to \"default\".")
gps <- rep("", length(nodes))
}
newNodeData <- tibble::tibble(node=nodes, group=gps)
newNodeData$group[newNodeData$group %in% c(""," ")] <- "<default>"
if(replace) {
if(!causalloop:::allEdfNodesListedInNdf(CLD)){
stop("CLD$edges$from and/or CLD$edges$to contain nodes that are absent in CLD$nodes.")
}
CLD$nodes <- newNodeData
} else {
CLD$nodes <- CLD$nodes %>%
dplyr::filter(!(node %in% nodes)) %>%
dplyr::bind_rows(newNodeData)
}
if(sorted) CLD$nodes <- CLD$nodes %>% dplyr::arrange(node)
CLD
}
L <- CLD(from     = c("a","a","b","c","d","d","e"),
to       = c("b","c","a","d","b","a","d"),
polarity = c(1,1,-1,-1,1,-1,1)) %>%
addNodeData(tibble::tibble(node="c", group="core"))
L
L <- CLD(from     = c("a","a","b","c","d","d","e"),
to       = c("b","c","a","d","b","a","d"),
polarity = c(1,1,-1,-1,1,-1,1)) %>%
addNodeData(tibble::tibble(node="c", group="core")) %>%
addNodeGroup("core", fontcolor="red", color="yellow")
addNodeGroup <- function(CLD, groups, ...){
stopifnot(class(CLD) == "CLD")
stopifnot(is.character(groups))
if(any(duplicated(groups))) stop("Duplicate groups specified.")
if(any(groups %in% CLD$formats$node$group)){
stop("Some groups already exist in the supplied CLD object.")
}
tmp <- CLD$formats$node %>%
dplyr::filter(group == "<default>") %>%
dplyr::mutate(dummy=1) %>%
dplyr::select(-group)
newNodeData <- dplyr::left_join(dplyr::tibble(group=groups, dummy=1),
tmp, by="dummy") %>%
dplyr::select(-dummy)
CLD$formats$node <- dplyr::bind_rows(CLD$formats$node, newNodeData)
setNodeFormat(CLD, groups, ...)
}
L <- CLD(from     = c("a","a","b","c","d","d","e"),
to       = c("b","c","a","d","b","a","d"),
polarity = c(1,1,-1,-1,1,-1,1)) %>%
addNodeData(tibble::tibble(node="c", group="core")) %>%
addNodeGroup("core", fontcolor="red", color="yellow")
#' Functions to format nodes and edges in a causal loop diagram (CLD)
#'
#' @param CLD An object of class CLD
#'
#' @param property The property of the edge or node being manipulated. Allowable values
#' are provided in the details.
#'
#' @param value Value of the parameter to be assigned. Note that this is not validated
#' against what values are allowed by GraphViz. See the documentation for GraphViz
#' for a list of allowable values.
#'
#' @param polarity Polarity of edges for which the edge format is being manipulated.
#' When this parameter is not specified, \code{setEdgeFormat()} will apply the format
#' change to both positive and negative links (with warning).
#'
#' @param group Character vector of group label(s) of nodes for which the node
#' format is being manipulated.  When this parameter is not specified,
#' \code{setNodeFormat()} applies the formatting to all node groups that are
#' currently included in the \code{CLD} object (under \code{$formats$node$group}).
#'
#' @param ... Format parameters as described in the details section below.
#'
#' @details For \code{setEdgeFormat()}, the following parameters are acted upon (all
#' others are ignored):
#' \itemize{
#'    \item{\code{style}} --- Line style (e.g., \code{"solid"} or \code{"dotted"})
#'    \item{\code{color}} --- Line color
#'    \item{\code{arrowhead}} --- Arrowhead style (e.g., \code{"vee"}, \code{"normal"},
#'    \code{"box"}, or \code{"diamond"}).
#'    \item{\code{penwidthAdj}} ---  Pen width adjustment factor. This gets multiplied
#'    by the edge weight to establish the thickness ("pen width") of each line.
#' }
#' For \code{setNodeFormat()}, the following parameters are acted upon (all
#' others are ignored):
#' \itemize{
#'    \item{\code{shape}} --- Node shape (e.g., \code{"rectangle"}, \code{"oval"},
#'    \code{"box"} or \code{"egg"})
#'    \item{\code{style}} --- Node line style (e.g., \code{"solid"}, \code{"dashed"},
#'    \code{"dotted"} or \code{"bold"})
#'    \item{\code{color}} --- Line color for the node shape
#'    \item{\code{fillcolor}} --- Fill color for the node
#'    \item{\code{fontname}} --- Font for the node label
#'    \item{\code{fontcolor}} --- Font color for the node label
#'    \item{\code{height}} --- Base height of the node (all graphs are plotted with
#'    \code{fixedsize = FALSE}, such that height and width change to accomodate the
#'    node labels)
#'    \item{\code{width}} --- Base width of the node (all graphs are plotted with
#'    \code{fixedsize = FALSE}, such that height and width change to accomodate the
#'    node labels)
#' }
#' Default attributes are adopted unless the attributes are specified through the
#' function.
#'
#' @return An updated CLD object.
#'
#' @examples
#' L <- CLD(from = c("a","a","c"),
#'          to   = c("b","c","a")) %>%
#'   setEdgeFormat("color", "midnightblue", polarity=-1) %>%
#'   setNodeFormat("fillcolor", "yellow")
#' #plot(L)
#' @export setEdgeFormat
setEdgeFormat <- function(CLD, property, value, polarity){
stopifnot(class(CLD) == "CLD")
stopifnot(property %in% c("style","color","arrowhead","penwidthAdj"))
if(missing(polarity)){
warning("No 'polarity' value was specified. Applying format change to +/- links.")
CLD$formats$edge[,property] <- value
} else{
stopifnot(polarity %in% c(-1,1))
CLD$formats$edge[polarity,property] <- value
}
return(CLD)
}
#' @rdname setEdgeFormat
#' @export setNodeFormat
setNodeFormat <- function(CLD, groups, ...){
nattribNames <- c("shape","style","color","fillcolor",
"fontname","fontcolor","height","width")
stopifnot(class(CLD) == "CLD")
dots <- list(...)
dots <- dots[names(dots) %in% nattribNames]
if(missing(groups)){
if(nrow(CLD$formats$node) > 1){
warning("No 'group' values were specified. Applying format change to all groups.")
}
for(nattrib in names(dots)){
nattribVal <- dots[[nattrib]]
stopifnot(is.vector(nattribVal))
if(length(nattribVal) != 1){
stop(paste("Parameter",nattrib,"must be of length 1 when no groups are specified."))
}
CLD$formats$node[,nattrib] <- nattribVal
}
} else{
stopifnot(is.character(groups))
stopifnot(all(!duplicated(groups)))
if(!all(groups %in% CLD$formats$node$group)){
stop('Not all values in "groups" are defined in the CLD object. See ?addNodeGroup')
}
for(nattrib in names(dots)){
nattribVals <- dots[[nattrib]]
stopifnot(is.vector(nattribVals))
if(length(nattribVals) == 1){
if(length(groups) > 1) {
warning(paste0("Applying ", nattrib, "=", nattribVals,
" to all node groups."))
}
} else if(length(nattribVals) != length(groups)){
stop(paste("Parameter", nattrib,
"must be length 1 or have length equal to length(groups)."))
}
tmp <- dplyr::tibble(group=groups)
tmp[,nattrib] <- nattribVals
modifiedGpNodeData <- CLD$formats$node[,names(CLD$formats$node) != nattrib] %>%
dplyr::filter(group %in% groups) %>%
dplyr::left_join(tmp, by="group") %>%
dplyr::select("group", nattribNames)
otherGpNodeData <- CLD$formats$node %>%
dplyr::filter(!(group %in% groups))
CLD$formats$node <- dplyr::bind_rows(modifiedGpNodeData, otherGpNodeData) %>%
dplyr::arrange(group)
}
}
CLD
}
#' Create a format class for a group of nodes in a causal loop diagram.
#'
#' @description This function specifies the node attributes for a group of nodes, allowing
#'   easy format management for node groups.
#'
#' @param CLD A causal loop diagram object
#' @param groups A character vector indicating the group name(s)
#' @param ... Other node attributes passed to \code{setNodeFormat()}.
#'
#' @return An updated CLD object; in particular, with updated \code{$formats$node} dataset.
#' @export
#'
#' @seealso \code{\link{setNodeFormat}}
#'
#' @examples
#' L <- CLD(from = c("a","a","c","c","d"),
#'          to   = c("b","c","a","d","a")) %>%
#'   addNodeData(tibble(node  = c("c","d","e","f"),
#'                      group = c("I"," ","II","I"))) %>%
#'   addNodeGroup(groups=c("I","II"),
#'                fillcolor="yellow",
#'                shape=c("box","ellipse"))
addNodeGroup <- function(CLD, groups, ...){
stopifnot(class(CLD) == "CLD")
stopifnot(is.character(groups))
if(any(duplicated(groups))) stop("Duplicate groups specified.")
if(any(groups %in% CLD$formats$node$group)){
stop("Some groups already exist in the supplied CLD object.")
}
tmp <- CLD$formats$node %>%
dplyr::filter(group == "<default>") %>%
dplyr::mutate(dummy=1) %>%
dplyr::select(-group)
newNodeData <- dplyr::left_join(dplyr::tibble(group=groups, dummy=1),
tmp, by="dummy") %>%
dplyr::select(-dummy)
CLD$formats$node <- dplyr::bind_rows(CLD$formats$node, newNodeData)
setNodeFormat(CLD, groups, ...)
}
#' Load node data into a CLD object
#'
#' @description This function takes a \emph{node data frame}, consisting of character
#'   variables \code{node} and (optionally) \code{group}, and populates the \code{nodes}
#'   list element in the supplied \code{CLD} object.
#'
#' @param CLD A causal loop diagram (CLD) object.
#'
#' @param ndf A node data frame containing at least a character column \code{node}.
#'   When \code{ndf} is specified, \code{edf2CLD()} loads the node information into the
#'   CLD object and checks the names of the variables contained in \code{edf$from} and
#'   \code{edf$to} for membership in \code{ndf$node}. This data frame may optionally contain
#'   a column named \code{group} to designate individual variables into groups. All other
#'   variables are ignored.
#'
#' @param replace If \code{TRUE}, \code{addNodeData()} will replace the existing
#'   \code{nodes} list element within the supplied \code{CLD} object. If \code{FALSE},
#'   the existing \code{nodes} data will be updated to include any new information
#'   embedded within \code{ndf}. Importantly, when \code{replace == TRUE}, the function
#'   verifies that all nodes represented in the \code{edges} table within the \code{CLD}
#'   object are listed in the supplied \code{ndf} (i.e., in \code{ndf$node}).
#'
#' @param sorted If \code{TRUE}, the \code{nodes} list element in the returned \code{CLD}
#'   object is sorted in order of the node name (column \code{node}).
#'
#' @return An updated CLD object.
#' @export
#'
#' @examples
#' \dontrun{
#' L <- CLD(from=c("a","a","c","c","d"), to=c("b","c","a","d","a"))
#' L$nodes
#' ndat <- tibble(node=c("c","d","e","f"), group=c("I"," ","II","I"))
#' L <- addNodeData(L, ndat)
#' L$nodes #note updating behavior - also that the missing value gets mapped to "<default>"
#' M <- addNodeData(L, ndat, replace=TRUE) #produces error
#' }
addNodeData <- function(CLD, ndf, replace=FALSE, sorted=TRUE){
stopifnot(class(CLD) == "CLD")
stopifnot(is.data.frame(ndf))
stopifnot("node" %in% names(ndf))
stopifnot(is.character(ndf$node))
nodes <- ndf$node
if(any(duplicated(nodes))){
stop("Duplicate node(s) specified in the 'ndf' table.")
}
if("group" %in% names(ndf)){
stopifnot(is.character(ndf$group))
gps <- ndf$group
} else {
warning("No 'group' variable specified in parameter 'ndf'. Setting to \"default\".")
gps <- rep("", length(nodes))
}
newNodeData <- tibble::tibble(node=nodes, group=gps)
newNodeData$group[newNodeData$group %in% c(""," ")] <- "<default>"
if(replace) {
if(!causalloop:::allEdfNodesListedInNdf(CLD)){
stop("CLD$edges$from and/or CLD$edges$to contain nodes that are absent in CLD$nodes.")
}
CLD$nodes <- newNodeData
} else {
CLD$nodes <- CLD$nodes %>%
dplyr::filter(!(node %in% nodes)) %>%
dplyr::bind_rows(newNodeData)
}
if(sorted) CLD$nodes <- CLD$nodes %>% dplyr::arrange(node)
CLD
}
L <- CLD(from     = c("a","a","b","c","d","d","e"),
to       = c("b","c","a","d","b","a","d"),
polarity = c(1,1,-1,-1,1,-1,1)) %>%
addNodeData(tibble::tibble(node="c", group="core")) %>%
addNodeGroup("core", fontcolor="red", color="yellow")
L
plot(L)
CLD <- L
CLD$formats$node %>% dplyr::rename(type=group)
plot.CLD <- function(CLD, nodes=NULL, steps = 1,
recolor=TRUE, textWidth = 10) {
stopifnot(class(CLD) == "CLD")
#first, make sure all nodes in the edges table are in the nodes table
if(!causalloop:::allEdfNodesListedInNdf(CLD)){
stop("CLD$edges contains nodes that are absent in CLD$nodes.")
}
if(!all(CLD$nodes$group %in% CLD$formats$node$group)){
zz <- setdiff(CLD$nodes$group, CLD$formats$node$group)
stop(paste0("Node group(s) '", paste(zz, collapse="', '"),
"' do not exist. Use addNodeGroup()."))
}
#map node data to what DiagrammeR wants (integer node IDs)
ndf <- DiagrammeR::create_node_df(n     = nrow(CLD$nodes),
type  = CLD$nodes$group,
label = CLD$nodes$node)
nodeFmtData <- CLD$formats$node %>% dplyr::rename(type=group)
ndf  <- dplyr::left_join(ndf, nodeFmtData, by="type")
nodeIDs <- ndf %>% dplyr::select(id,label)
edf <- CLD$edges %>%
dplyr::left_join(CLD$formats$edge, by="polarity") %>%
dplyr::rename(label=from) %>%
dplyr::left_join(nodeIDs, by="label") %>%
dplyr::select(-label) %>%
dplyr::rename(from=id, label=to) %>%
dplyr::left_join(nodeIDs, by="label") %>%
dplyr::select(-label) %>%
dplyr::rename(to=id)
edf <- DiagrammeR::create_edge_df(from      = edf$from,
to        = edf$to,
polarity  = edf$polarity,
style     = edf$style,
color     = edf$color,
arrowhead = edf$arrowhead,
penwidth  = edf$penwidthAdj*edf$weight)
if(!is.null(nodes)){
if(any(!(nodes %in% CLD$nodes$node))){
warning(paste0("The following nodes were not in the CLD ",
"and will be ignored:\n     '",
paste0(setdiff(nodes, CLD$nodes$node),
collapse="'\n     '")), "'")
nodes <- nodes[nodes %in% CLD$nodes$node]
}
if(length(nodes)==0) stop("No nodes present in the CLD!")
nodes <- ndf$id[ndf$label %in% nodes]  #map nodes to node indices
stopifnot(is.numeric(steps) & length(steps)==1)
steps <- floor(steps)
inNodes <- outNodes <- origNodes <- nodes
if(steps>0)  for(i in 1:steps) {
inNodes  <- unique(c(inNodes, edf$from[which(edf$to %in% inNodes)]))
outNodes <- unique(c(outNodes, edf$to[which(edf$from %in% outNodes)]))
}
nodes <- unique(c(inNodes,outNodes))
ndf <- ndf %>% dplyr::filter(id %in% nodes)
edf <- edf %>% dplyr::filter(from %in% nodes & to %in% nodes)
ix <- which(!(edf$from %in% origNodes) & !(edf$to %in% origNodes))
if(recolor & length(ix)>0) edf$color[ix] <- "gray70"
}
ndf$label <- stringr::str_wrap(ndf$label, width = textWidth)
g <- DiagrammeR::create_graph(nodes_df=ndf, edges_df=edf) %>%
DiagrammeR::add_global_graph_attrs(attr      = "overlap",
value     = "false",
attr_type = "graph")
DiagrammeR::render_graph(g)
}
L <- CLD(from     = c("a","a","b","c","d","d","e"),
to       = c("b","c","a","d","b","a","d"),
polarity = c(1,1,-1,-1,1,-1,1)) %>%
addNodeData(tibble::tibble(node="c", group="core")) %>%
addNodeGroup("core", fontcolor="red", color="yellow")
plot(L)
